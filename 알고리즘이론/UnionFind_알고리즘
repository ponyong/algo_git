Disjoint Set

서로 중복되지 않는 부분 집합 => 서로소 집합 자료구조 

공통 원소가 없는 즉, 상호 배타적인 부분 집합들로 이루어진 원소들에 대한 자료구조

Union-Find => Disjoint Set을 표현하기 위해 사용되는 알고리즘

배열로도 구현이 가능하지만 효율성을 위해 트리구조로 구현한다.

<핵심 이론 >

make-set(x)
    각 노드는 모두 루트 노드이므로 N개의 루트 노드 생성 및 자기 자신으로 초기화 한다.
    
union( x , y ) 
  x, y 의 루트 노드를 탐색하여 다르면 한쪽을 다른 한쪽의 자손으로 만들어 트리를 합한다.
   일반적으로 y 를 x의 자손에 넣어 연산을 진행한다.
  
find(x)
  x 의 루트 노드를 탐색한다. 
  
< 사용 예시 > 

Kruskal MST 에서 새로 추가할 간선의 양 끝 정점이
같은 집합에 속하였는지 (사이클) 검사하는 방법

두 원소가 같은 집합 속에 속해 있는지 검사하는 방법

<개선 사항>

트리 구조가 완전 비대칭인 경우  union과 find 의 복잡도가 모두 O(N)
배열로 구현하는 것보다 비효율적

int find(int x) {
  if (root[x] == x) {
      return x;
  } else {
      // "경로 압축(Path Compression)"
      // find 하면서 만난 모든 값의 부모 노드를 root로 만든다.
      return root[x] = find(root[x]);
  }
}
경로 압축 (Path Compression) 

루트의 값만 중요하고 그 Path는 중요한게 아니므로 루트를 찾아 그 아래에 Union을 실행
